科目名: プログラミング実習III
課題: B7
番号: 37022493
氏名: 西岡優太
作成: 2023年11月19日

----------------------------------------
[課題 7.1]

  double 型の配列 a とその サイズ n, および整数 k (0≤k<n) が与えられたときに, 次の処理を行う関数 void swapmin(int n, double *a, int k) を作成せよ.
  
  a[k]〜a[n-1] の中の最小値を a[i] とするとき, a[k] と a[i] の値を交換する.
  関数は swapmin.c に格納し, 下記の swapmin_test.c とリンクして動作確認せよ.
  
  swapmin_test.c は, 配列 a にデータを入力した後, k を入力して swapmin(n, a, k) を実行しては配列 a の内容を出力する, という動作を繰り返す (プログラムを読んで理解せよ).
  
  自分で適切な入力を与えて, swapmin の動作が正しいことを確認せよ.
  
  (1) n = 5,   a = 5, 4, 3, 2, 1,   k = 0 を入力 →   a = 1, 4, 3, 2, 5 となることを確認せよ.
  
  (2) n = 5,   a = 5, 4, 3, 1, 2   k = 1 を入力 →   a = 5, 1, 3, 4, 2 となることを確認せよ.
  
  (3) n = 5,   a = 6, 2, 4, 9, 8   に対して, k = 0, 1, 2, 3 を続けて入力すると a が昇順にソートされることを確認せよ. (下線はソート済みであることを表わす.)
  
  k = 0 を入力 →   a = 2, 6, 4, 9, 8
  k = 1 を入力 →   a = 2, 4, 6, 9, 8
  k = 2 を入力 →   a = 2, 4, 6, 9, 8
  k = 3 を入力 →   a = 2, 4, 6, 8, 9
  
  [実行結果]
  
  (1) n = 5,   a = 5, 4, 3, 2, 1,   k = 0 を入力 →   a = 1, 4, 3, 2, 5 となることを確認せよ.
  
      (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc swapmin.c swapmin_test.c -W
      (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
      n = 5
      [0] : 5
      [1] : 4
      [2] : 3
      [3] : 2
      [4] : 1
      [0]    5.00000
      [1]    4.00000
      [2]    3.00000
      [3]    2.00000
      [4]    1.00000
      k = 0
      swapmin(n, a, 0)
      [0]    1.00000
      [1]    4.00000
      [2]    3.00000
      [3]    2.00000
      [4]    5.00000
      k = %  
  
  (2) n = 5,   a = 5, 4, 3, 1, 2   k = 1 を入力 →   a = 5, 1, 3, 4, 2 となることを確認せよ.
  
      (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
      n = 5
      [0] : 5
      [1] : 4
      [2] : 3
      [3] : 2
      [4] : 1
      [0]    5.00000
      [1]    4.00000
      [2]    3.00000
      [3]    2.00000
      [4]    1.00000
      k = 1
      swapmin(n, a, 1)
      [0]    5.00000
      [1]    1.00000
      [2]    3.00000
      [3]    2.00000
      [4]    4.00000
      k = %         
  
  (3) n = 5,   a = 6, 2, 4, 9, 8   に対して, k = 0, 1, 2, 3 を続けて入力すると a が昇順にソートされることを確認せよ. (下線はソート済みであることを表わす.)
  
      (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
      n = 5
      [0] : 6
      [1] : 2
      [2] : 4
      [3] : 9
      [4] : 8
      [0]    6.00000
      [1]    2.00000
      [2]    4.00000
      [3]    9.00000
      [4]    8.00000
      k = 0
      swapmin(n, a, 0)
      [0]    2.00000
      [1]    6.00000
      [2]    4.00000
      [3]    9.00000
      [4]    8.00000
      k = 1
      swapmin(n, a, 1)
      [0]    2.00000
      [1]    4.00000
      [2]    6.00000
      [3]    9.00000
      [4]    8.00000
      k = 2
      swapmin(n, a, 2)
      [0]    2.00000
      [1]    4.00000
      [2]    6.00000
      [3]    9.00000
      [4]    8.00000
      k = 3
      swapmin(n, a, 3)
      [0]    2.00000
      [1]    4.00000
      [2]    6.00000
      [3]    8.00000
      [4]    9.00000
      k = %  
  
  [感想]
  単純選択法について学べた。
  要素を交換する回数が少なく済むのがメリットだと感じた。

----------------------------------------
[課題 7.2]

  課題 (7-1) の swapmin の動作を k=0〜n-2 について行えば, a[0]〜a[n-1] を昇順にソートできる. この考え方に基づくソーティングのアルゴリズムを「単純選択法」と言う. 単純選択法により a[0]〜a[n-1] のソートを行う関数 void sort(int n, double *a) を作成し, selection_sort.c に格納せよ.
  下記の sort_test.c とリンクし, 動作を確認せよ. まず, 手入力で
  
  n = 5, データ = 1 2 3 4 5   →   出力 1.0 2.0 3.0 4.0 5.0
  n = 5, データ = 5 4 3 2 1   →   出力 1.0 2.0 3.0 4.0 5.0
  n = 3, データ = 0.3 0.2 0.1   →   出力 0.1 0.2 0.3
  
  を確認し, 次に diff により次の入出力が得られることを確認せよ.
      
  [in.txt]	
   4  -0.1 1.1 0 3.1 
   4  -0.1 1.1 3.1 0 
   4  -0.1 0 1.1 3.1 
   4  -0.1 0 3.1 1.1 
   4  -0.1 3.1 1.1 0 
   4  -0.1 3.1 0 1.1 
   4  1.1 -0.1 0 3.1 
   4  1.1 -0.1 3.1 0 
   4  1.1 0 -0.1 3.1 
   4  1.1 0 3.1 -0.1 
   4  1.1 3.1 -0.1 0 
   4  1.1 3.1 0 -0.1 
   4  0 -0.1 1.1 3.1 
   4  0 -0.1 3.1 1.1 
   4  0 1.1 -0.1 3.1 
   4  0 1.1 3.1 -0.1 
   4  0 3.1 -0.1 1.1 
   4  0 3.1 1.1 -0.1 
   4  3.1 -0.1 1.1 0 
   4  3.1 -0.1 0 1.1 
   4  3.1 1.1 -0.1 0 
   4  3.1 1.1 0 -0.1 
   4  3.1 0 -0.1 1.1 
   4  3.1 0 1.1 -0.1 
   4  -0.1 -0.1 1.1 0
   4  -0.1 -0.1 0 1.1
   4  -0.1 1.1 0 -0.1
   4  -0.1 1.1 -0.1 0
   4  -0.1 0 -0.1 1.1
   4  -0.1 0 1.1 -0.1
   4  1.1 -0.1 -0.1 0
   4  1.1 -0.1 0 -0.1
   4  1.1 0 -0.1 -0.1
   4  0 -0.1 -0.1 1.1
   4  0 -0.1 1.1 -0.1
   4  0 1.1 -0.1 -0.1
   4  -0.1 -0.1 1.1 1.1
   4  -0.1 1.1 -0.1 1.1
   4  -0.1 1.1 1.1 -0.1
   4  1.1 -0.1 -0.1 1.1
   4  1.1 -0.1 1.1 -0.1
   4  1.1 1.1 -0.1 -0.1
   4  -0.1 -0.1 -0.1 1.1
   4  -0.1 1.1 -0.1 -0.1
   4  -0.1 -0.1 1.1 -0.1
   4  -0.1 -0.1 -0.1 1.1
   4  -0.1 -0.1 -0.1 -0.1
   16  0.4 1.6  0.1 1.1 0.8 1.4 0.7 0.6  0.9 1.0 1.2 0.5 0.2 1.3 1.5 0.3 
   16  1.4 0.6  0.1 0.9 0.8 1.0 0.5 1.3 1.6  1.5 0.7 1.2 0.4 1.1 0.3 0.2 
   16  1.3 0.9 0.1 1.2 0.6  1.5 1.1 0.4 1.0 0.7 0.5 0.3 1.4 0.8 0.2 1.6
  
  [exp.txt]
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 0.0 1.1 3.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 0.0 1.1
   -0.1 -0.1 1.1 1.1
   -0.1 -0.1 1.1 1.1
   -0.1 -0.1 1.1 1.1
   -0.1 -0.1 1.1 1.1
   -0.1 -0.1 1.1 1.1
   -0.1 -0.1 1.1 1.1
   -0.1 -0.1 -0.1 1.1
   -0.1 -0.1 -0.1 1.1
   -0.1 -0.1 -0.1 1.1
   -0.1 -0.1 -0.1 1.1
   -0.1 -0.1 -0.1 -0.1
   0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6
   0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6
   0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6
  
  [実行結果]
  
  (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc selection_sort.c sort_test.c -W
  (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
  n = 5
  [0] : 1
  [1] : 2
  [2] : 3
  [3] : 4
  [4] : 5
   1.0 2.0 3.0 4.0 5.0
  n = 5
  [0] : 5
  [1] : 4
  [2] : 3
  [3] : 2
  [4] : 1
   1.0 2.0 3.0 4.0 5.0
  n = 3
  [0] : 0.3
  [1] : 0.2
  [2] : 0.1
   0.1 0.2 0.3
  n = %    
  
  (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out <in.txt> out.txt
  (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % diff out.txt exp.txt -w
  
  [感想]
  7_1での処理をk=0からk=n-2まで行う関数を作った。
  最小要素の探索にかかる時間を削減できる方法はないのか気になった。

----------------------------------------
[課題 7.3]

  double 型の配列 a とその サイズ n, および整数 k (1≤k<n) が与えられたときに, 次の処理を行う関数 void insert(int n, double *a, int k) を作成せよ.
     ・a[k] と a[k-1] を比較する. a[k]≥a[k-1] なら終了. a[k]<a[k-1] なら a[k] と a[k-1] の値を交換し, 処理を続ける.
     ・a[k-1] と a[k-2] を比較する. a[k-1]≥a[k-2] なら終了. a[k-1]<a[k-2] なら a[k-1] と a[k-2] の値を交換し, 処理を続ける.
     ・a[k-2] と a[k-3] を比較する. a[k-2]≥a[k-3] なら終了. a[k-2]<a[k-3] なら a[k-2] と a[k-3] の値を交換し, 処理を続ける.
       …
     ・a[1] と a[0] を比較する. a[1]≥a[0] なら終了. a[1]<a[0] なら a[1] と a[0] の値を交換する (ここまで来れば終了).
  
  [実行結果]
  
     (1) n = 5,   a = 2, 4, 6, 8, 5,   k = 4 を入力 →   a = 2, 4, 5, 6, 8 となることを確認せよ.
  
     (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc insert.c insert_test.c -W
     insert.c:1:17: warning: unused parameter 'n' [-Wunused-parameter]
     void insert(int n, double *a, int k)
                     ^
     1 warning generated.
     (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
     n = 5
     [0] : 2
     [1] : 4
     [2] : 6
     [3] : 8
     [4] : 5
     [0]    2.00000
     [1]    4.00000
     [2]    6.00000
     [3]    8.00000
     [4]    5.00000
     k = 4
     insert(n, a, 4)
     [0]    2.00000
     [1]    4.00000
     [2]    5.00000
     [3]    6.00000
     [4]    8.00000
     k = % 
  
     (2) n = 5,   a = 3, 4, 6, 2, 1,   k = 3 を入力 →   a = 2, 3, 4, 6, 1 となることを確認せよ.
  
     (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
     n = 5
     [0] : 3   
     [1] : 4
     [2] : 6
     [3] : 2
     [4] : 1
     [0]    3.00000
     [1]    4.00000
     [2]    6.00000
     [3]    2.00000
     [4]    1.00000
     k = 3
     insert(n, a, 3)
     [0]    2.00000
     [1]    3.00000
     [2]    4.00000
     [3]    6.00000
     [4]    1.00000
     k = %    
  
     (3) n = 5,   a = 6, 2, 4, 9, 8   に対して   k = 1, 2, 3, 4 を入力すると a が昇順にソートされることを確認せよ.
  
     (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out                      
     n = 5
     [0] : 6
     [1] : 2
     [2] : 4
     [3] : 9
     [4] : 8
     [0]    6.00000
     [1]    2.00000
     [2]    4.00000
     [3]    9.00000
     [4]    8.00000
     k = 1
     insert(n, a, 1)
     [0]    2.00000
     [1]    6.00000
     [2]    4.00000
     [3]    9.00000
     [4]    8.00000
     k = 2
     insert(n, a, 2)
     [0]    2.00000
     [1]    4.00000
     [2]    6.00000
     [3]    9.00000
     [4]    8.00000
     k = 3
     insert(n, a, 3)
     [0]    2.00000
     [1]    4.00000
     [2]    6.00000
     [3]    9.00000
     [4]    8.00000
     k = 4
     insert(n, a, 4)
     [0]    2.00000
     [1]    4.00000
     [2]    6.00000
     [3]    8.00000
     [4]    9.00000
     k = %  
  
  [感想]
     指定した位置の要素とその手前の要素を比較して値を交換し続けることで昇順に要素を並べるアルゴリズムを理解できた。

----------------------------------------
[課題 7.4]

  課題 (7-3) の insert の動作を k=1〜n-1 について行えば, a[0]〜a[n-1] を昇順にソートできる. この考え方に基づくソーティングのアルゴリズムを「単純挿入法」と言う. 単純挿入法により a[0]〜a[n-1] のソートを行う関数 void sort(int n, double *a) をファイル insertion_sort.c に作成せよ.
  insertion_sort.c を課題 (7-2) の sort_test.c とリンクして動作確認せよ.
  
  [実行結果]
  
     (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc insertion_sort.c sort_test.c -w
     (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
     n = 5
     [0] : 6
     [1] : 2
     [2] : 4
     [3] : 9
     [4] : 8
      2.0 4.0 6.0 8.0 9.0
     n = %      
  
  [感想]
     7.3におけるkの値を1からn-1まで実行することで、昇順にソートする処理が一つの関数で行うことができるようにした。
     もし、5 4 3 2 1の順で入力した時の時間計算量はO(n^2)になるので、それを改善したアルゴリズムを見つけたいと思う。

----------------------------------------
[課題 7.5]

  次は, ソートの計算に要する時間を計測するプログラム sort_cpu.c の原型 (未完成) である. 下記の指示に従ってプログラムを完成させよ.
     1.array_set_rand の完成
         a[0]〜a[n-1] に乱数 (rand() を呼び出して得られる値) を代入するようにせよ.
     2.array_set_sorted の完成
         a[0]〜a[n-1] にそれぞれ 0, 1, 2, …, n-1 を代入するようにせよ.
     3.array_set_reverse の完成
         a[0]〜a[n-1] にそれぞれ n, n-1, n-2, …, 1 を代入するようにせよ.
     4.1〜3 の確認
       この時点での sort_cpu.c と selection_sort.c をコンパイル＆リンクして実行し, 下記のような出力が得られることを確認せよ. ただし, 青字の部分は環境に依存して異なる.
          略
     5.array_copy の完成
       r[0]〜r[n-1] の値を a[0]〜a[n-1] にコピーするようにせよ.
     6.sort_cpu の完成
       プログラムの 「/** ここを埋めて関数を完成させよ **/」の部分に次の処理をコーディングせよ.
       完成した sort_cpu.c を selection_sort.c とリンクして実行してみよ. 下記のように, 配列の先頭の 8 要素の内容に続いて, n = 2, 4, 8 のソートに要した CPU 時間 (秒) が表示されることを確認せよ (フォーマットは厳密に一致しなくてよい).
         略
     7.単純選択法 (selection_sort.c) の CPU 時間
       sort_cpu.c の 6〜7 行目の MIN_N, MAX_N の値をそれぞれ 1024, 65536 に変更し, 単純選択法の実行にかかる時間を計測せよ. 実行結果をレポートに示せ.
     8.最適化
       gcc コマンドに最適化オプション -O2 を付加して同じプログラムをコンパイルせよ.
     
       次の点について考察し, 結果をレポートに記せ.
     
       ・最適化を行なわない場合と行なった場合で, 実行時間がどの程度異なるか.
       ・最適を行った場合について, 初期データが乱数, 正順, 逆順の場合の計算時間はどのように異なるか.
       ・最適を行った場合について, n の増加に対して計算時間はどのような割合で増えているか. レポートに記せ.
     9.単純挿入法 (insertion_sort.c) の CPU 時間
       sort_cpu.c と insertion_sort.c をリンクして実行せよ. 単純選択法と同じ項目 (最適化の有無, 初期データの違い, n と計算時間の関係) について考察し, 結果をレポートに記せ.
  
  [実行結果]
    (7)
        (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc sort_cpu.c selection_sort.c -W
        (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out                           
        乱数
               16807.00000
           282475249.00000
          1622650073.00000
           984943658.00000
          1144108930.00000
           470211272.00000
           101027544.00000
          1457850878.00000
        n = 1024
        cpu =    0.002297 [sec]
        n = 2048
        cpu =    0.008141 [sec]
        n = 4096
        cpu =    0.023444 [sec]
        n = 8192
        cpu =    0.069759 [sec]
        n = 16384
        cpu =    0.276298 [sec]
        n = 32768
        cpu =    1.100845 [sec]
        n = 65536
        cpu =    4.394163 [sec]
        正順
                   0.00000
                   1.00000
                   2.00000
                   3.00000
                   4.00000
                   5.00000
                   6.00000
                   7.00000
        n = 1024
        cpu =    0.001081 [sec]
        n = 2048
        cpu =    0.004292 [sec]
        n = 4096
        cpu =    0.017163 [sec]
        n = 8192
        cpu =    0.068875 [sec]
        n = 16384
        cpu =    0.274090 [sec]
        n = 32768
        cpu =    1.094823 [sec]
        n = 65536
        cpu =    4.386266 [sec]
        逆順
               65535.00000
               65534.00000
               65533.00000
               65532.00000
               65531.00000
               65530.00000
               65529.00000
               65528.00000
        n = 1024
        cpu =    0.001276 [sec]
        n = 2048
        cpu =    0.004844 [sec]
        n = 4096
        cpu =    0.019540 [sec]
        n = 8192
        cpu =    0.077955 [sec]
        n = 16384
        cpu =    0.310378 [sec]
        n = 32768
        cpu =    1.236702 [sec]
        n = 65536
        cpu =    4.946590 [sec]
    (8)
        (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc -O2 sort_cpu.c selection_sort.c -W
        (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
        乱数
               16807.00000
           282475249.00000
          1622650073.00000
           984943658.00000
          1144108930.00000
           470211272.00000
           101027544.00000
          1457850878.00000
        n = 1024
        cpu =    0.002064 [sec]
        n = 2048
        cpu =    0.007772 [sec]
        n = 4096
        cpu =    0.035826 [sec]
        n = 8192
        cpu =    0.086693 [sec]
        n = 16384
        cpu =    0.258941 [sec]
        n = 32768
        cpu =    0.889668 [sec]
        n = 65536
        cpu =    2.943791 [sec]
        正順
                   0.00000
                   1.00000
                   2.00000
                   3.00000
                   4.00000
                   5.00000
                   6.00000
                   7.00000
        n = 1024
        cpu =    0.001949 [sec]
        n = 2048
        cpu =    0.004175 [sec]
        n = 4096
        cpu =    0.011035 [sec]
        n = 8192
        cpu =    0.031334 [sec]
        n = 16384
        cpu =    0.103378 [sec]
        n = 32768
        cpu =    0.512634 [sec]
        n = 65536
        cpu =    2.130107 [sec]
        逆順
               65535.00000
               65534.00000
               65533.00000
               65532.00000
               65531.00000
               65530.00000
               65529.00000
               65528.00000
        n = 1024
        cpu =    0.002096 [sec]
        n = 2048
        cpu =    0.007231 [sec]
        n = 4096
        cpu =    0.018716 [sec]
        n = 8192
        cpu =    0.043992 [sec]
        n = 16384
        cpu =    0.142396 [sec]
        n = 32768
        cpu =    1.542897 [sec]
        n = 65536
        cpu =    4.420508 [sec]
    (9)
        [最適化なし]
        (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc sort_cpu.c insertion_sort.c -w
        (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out                           
        乱数
               16807.00000
           282475249.00000
          1622650073.00000
           984943658.00000
          1144108930.00000
           470211272.00000
           101027544.00000
          1457850878.00000
        n = 1024
        cpu =    0.002905 [sec]
        n = 2048
        cpu =    0.009541 [sec]
        n = 4096
        cpu =    0.027707 [sec]
        n = 8192
        cpu =    0.105188 [sec]
        n = 16384
        cpu =    0.421531 [sec]
        n = 32768
        cpu =    1.694941 [sec]
        n = 65536
        cpu =    6.800420 [sec]
        正順
                   0.00000
                   1.00000
                   2.00000
                   3.00000
                   4.00000
                   5.00000
                   6.00000
                   7.00000
        n = 1024
        cpu =    0.000005 [sec]
        n = 2048
        cpu =    0.000008 [sec]
        n = 4096
        cpu =    0.000015 [sec]
        n = 8192
        cpu =    0.000031 [sec]
        n = 16384
        cpu =    0.000058 [sec]
        n = 32768
        cpu =    0.000137 [sec]
        n = 65536
        cpu =    0.000235 [sec]
        逆順
               65535.00000
               65534.00000
               65533.00000
               65532.00000
               65531.00000
               65530.00000
               65529.00000
               65528.00000
        n = 1024
        cpu =    0.003336 [sec]
        n = 2048
        cpu =    0.013368 [sec]
        n = 4096
        cpu =    0.053461 [sec]
        n = 8192
        cpu =    0.212619 [sec]
        n = 16384
        cpu =    0.848718 [sec]
        n = 32768
        cpu =    3.420196 [sec]
        n = 65536
        cpu =   13.675860 [sec]

        [最適化あり]
        (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc -O2 sort_cpu.c insertion_sort.c -w                 
        (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
        乱数
               16807.00000
           282475249.00000
          1622650073.00000
           984943658.00000
          1144108930.00000
           470211272.00000
           101027544.00000
          1457850878.00000
        n = 1024
        cpu =    0.000959 [sec]
        n = 2048
        cpu =    0.003595 [sec]
        n = 4096
        cpu =    0.017248 [sec]
        n = 8192
        cpu =    0.052610 [sec]
        n = 16384
        cpu =    0.206199 [sec]
        n = 32768
        cpu =    0.831290 [sec]
        n = 65536
        cpu =    3.325620 [sec]
        正順
                   0.00000
                   1.00000
                   2.00000
                   3.00000
                   4.00000
                   5.00000
                   6.00000
                   7.00000
        n = 1024
        cpu =    0.000001 [sec]
        n = 2048
        cpu =    0.000001 [sec]
        n = 4096
        cpu =    0.000003 [sec]
        n = 8192
        cpu =    0.000006 [sec]
        n = 16384
        cpu =    0.000012 [sec]
        n = 32768
        cpu =    0.000024 [sec]
        n = 65536
        cpu =    0.000046 [sec]
        逆順
               65535.00000
               65534.00000
               65533.00000
               65532.00000
               65531.00000
               65530.00000
               65529.00000
               65528.00000
        n = 1024
        cpu =    0.001626 [sec]
        n = 2048
        cpu =    0.006529 [sec]
        n = 4096
        cpu =    0.025960 [sec]
        n = 8192
        cpu =    0.103284 [sec]
        n = 16384
        cpu =    0.412173 [sec]
        n = 32768
        cpu =    1.668929 [sec]
        n = 65536
        cpu =    6.696613 [sec]
  [感想]
    (8)に関して 
        最適化したほうが実行時間が早くなる.
        逆順でいうと最適化の効果をあまり感じられないが、乱数と正順に関して言えば最適化したほうが計算時間は半分ほどになっている。
        nの値がm倍(m:正の整数)になると、計算時間はnの計算時間のm^2倍になると言える。
    (9)に関して
        最適化したほうが計算時間が早くなる。
        単純選択法と同じくnの値がm倍(m:正の整数)になると、計算時間はnの計算時間のm^2倍になると言える。

----------------------------------------
[課題 7.6]

  クイックソートにより配列 a の先頭から n 個のデータのソートを行う関数 void sort(int n, double *a) を作成せよ (quick_sort.c に格納せよ).
  quick_sort.c が完成したら, sort_test.c とリンクして動作確認せよ.
  次に, sort_cpu.c と quick_sort.c をリンクして実行時間を観測せよ (コンパイルには最適化オプション -O2 を用いよ).
  
  [実行結果]
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc quick_sort.c sort_test.c -W
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out                        
    n = 5
    [0] : 2
    [1] : 4
    [2] : 1
    [3] : 7
    [4] : 5
     1.0 2.0 4.0 5.0 7.0
    n = %    
    
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc -O2 quick_sort.c sort_cpu.c -W 
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out
    乱数
           16807.00000
       282475249.00000
      1622650073.00000
       984943658.00000
      1144108930.00000
       470211272.00000
       101027544.00000
      1457850878.00000
    n = 1024
    cpu =    0.000093 [sec]
    n = 2048
    cpu =    0.000172 [sec]
    n = 4096
    cpu =    0.000364 [sec]
    n = 8192
    cpu =    0.000766 [sec]
    n = 16384
    cpu =    0.001581 [sec]
    n = 32768
    cpu =    0.003475 [sec]
    n = 65536
    cpu =    0.008208 [sec]
    正順
               0.00000
               1.00000
               2.00000
               3.00000
               4.00000
               5.00000
               6.00000
               7.00000
    n = 1024
    cpu =    0.000484 [sec]
    n = 2048
    cpu =    0.001876 [sec]
    n = 4096
    cpu =    0.006078 [sec]
    n = 8192
    cpu =    0.018567 [sec]
    n = 16384
    cpu =    0.069426 [sec]
    n = 32768
    cpu =    0.276804 [sec]
    n = 65536
    cpu =    1.101396 [sec]
    逆順
           65535.00000
           65534.00000
           65533.00000
           65532.00000
           65531.00000
           65530.00000
           65529.00000
           65528.00000
    n = 1024
    cpu =    0.000316 [sec]
    n = 2048
    cpu =    0.001198 [sec]
    n = 4096
    cpu =    0.004458 [sec]
    n = 8192
    cpu =    0.017552 [sec]
    n = 16384
    cpu =    0.069786 [sec]
    n = 32768
    cpu =    0.277357 [sec]
    n = 65536
    cpu =    1.099641 [sec]

  [感想]
    クイックソートは他のソートに比べて一般的に最速だと言われているそうだが、
    cpuの計算時間をみても確かにその通りだと感じた。他の言語でも実装してみたいと思う。

----------------------------------------
[課題 7.7]

  下記の指示に従って, 課題 (7-2) の単純選択法または課題 (7-4) の単純挿入法 (自分が理解しやすい方を選べ) の void sort(int n, double *a) を書き換え, 文字列 (文字配列) の配列をソートする void string_sort(int n, char (*a)[STRLEN+1]) を string_sort.c に作成せよ.
    ・string_sort.c の冒頭で標準ヘッダファイル string.h と, 次の "string_sort.h" をインクルードせよ.
    ・基本的には, sort(int n, double *a) の本体をコピーして, 次の書き換えを行えばよい.
      ・double 型変数の宣言 double x を, 文字配列変数の宣言 char x[STRLEN+1] に置き換える.
      ・double 型データの代入 x = y を, 文字列のコピー strcpy(x,y) に置き換える.
      (ただし, ポインタが理解できていれば, 一部の代入をそのまま (ポインタの代入) にして, 処理を効率化することができる (中上級者向き).)
      ・double 型データの大小比較 x<y を, 文字列の比較 strcmp(x,y)<0 に置き換える.
    ・下記の string_sort_test.c とリンクして実行し, in.txt のような入力に対して exp.txt のような出力が得られる (文字列のソートが正しく行われる) ことを確認せよ.
        [in.txt]	
        5
        tanaka
        yamada
        suzuki
        yamamoto
        nakamura
        
        [exp.txt]
        nakamura
        suzuki
        tanaka
        yamada
        yamamoto

  [実行結果]
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc string_sort.c string_sort_test.c -W
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out <in.txt> out.txt
    n = [0] : [1] : [2] : [3] : [4] : %                                                                                                                                                               
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % diff out.txt exp.txt -w
  
  [感想]
    この課題では、単純選択法を採択した。
    strcpy関数を使用して文字列の入れ替えをすることで実装することができた。

----------------------------------------
[課題 7.8]

  下記の指示に従って, 課題 (7_2) の単純選択法の void sort(int n, double *a) を書き換え, 次のように定義された構造体の配列を, 構造体中の age の昇順に, ただし age が等しいものは height の昇順にソートする関数 void str_sort(int n, record_t *a) を作成せよ. 関数は str_sort.c に格納せよ.
    ・str_sort.c の冒頭で標準ヘッダファイル string.h と, 次の "str_sort.h" をインクルードせよ.  
    ・基本的には, sort(int n, double *a) の本体をコピーして, 次の書き換えを行えばよい.
        ・double 型変数の宣言 double x を, 構造体型変数の宣言 record_t x に置き換える.
        ・double 型データの代入 x = y は, そのまま (record_t 型データの代入 x = y) にする.
        (ただし, ポインタが理解できていれば, 一部の代入を文字配列へのポインタの代入に置き換えて, 処理を効率化することができる (中上級者向き).)
        ・double 型データの大小比較 x<y を, 書き換える (書き方はいろいろ考えられる).
    ・下記の str_sort_test.c とリンクして実行し, in.txt のような入力に対して exp.txt のような出力が得られることを確認せよ.
        [in.txt]	
        6
        yamada 22 160.5
        yamamoto 22 177.4
        suzuki 21 165.3
        tanaka 20 170.0
        nakamura 22 179.7
        nakamura 21 175.3
        
        [exp.txt]
        tanaka     20 170.00
        suzuki     21 165.30
        nakamura   21 175.30
        yamada     22 160.50
        yamamoto   22 177.40
        nakamura   22 179.70
  
  [実行結果]
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % gcc str_sort.c str_sort_test.c -W 
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % ./a.out <in.txt> out.txt               
    n = [0].name : [0].age : [0].height : [1].name : [1].age : [1].height : [2].name : [2].age : [2].height : [3].name : [3].age : [3].height : [4].name : [4].age : [4].height : [5].name : [5].age : [5].height : %                                                                                                                                   
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 7回目 % diff out.txt exp.txt -w   
  
  [感想]
    7.7と異なるのは、並び替える要素が構造体で定義されていることだけなので難しくなかった。
    年齢が同じだった場合、身長が低い方をminに代入することでyamadaさんとyamamotoさんの入れ替えができた。
    また、文字列だけでなく年齢と身長も交換するので、構造体配列の要素の交換で済んだ。

----------------------------------------
[課題 B7 の感想]
今回は、並び替えのアルゴリズムに関して、単純選択法、単純挿入法、クイックソートを実装した。
C言語での実装はかなり苦戦したので、他の言語(Python)でも実装してみたいと思った。

