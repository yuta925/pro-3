科目名: プログラミング実習III
課題: B4
番号: 37022493
氏名: 西岡優太
作成: 2023年10月16日

----------------------------------------
[課題 4.1]
以下の指示に従い, n×n 行列に対する演算を行うための関数群を matrix.c に作成せよ.

(1) matrix_print
    まず, 下記の matrix.c と matrix1test.c (両者とも matrix.h をインクルードしている) をコンパイル・リンクし, 実行してみよ. 次のような出力が得られるはず.

 　 A
 　　0 1 2
 　　1 2 3
 　　2 3 4

    [実行結果]


void matrix_print(int n, double A[N][N]) は, 配列 A[N][N] に格納された n×n 行列のデータを標準出力に出力する関数である. この関数の中の printf の書式を適切に設定し, 下記と同様の出力が得られるようにせよ (diff で確認せよ).

(2) matrix_scan
    標準入力から n×n 行列のデータを配列 A[N][N] に読み込む関数 void matrix_scan(int n, double A[N][N]) を作成し, matrix.c に追加せよ.

    matrix.c を下記のテストプログラム(matrix2test)とリンクして実行し, 次のような実行結果が得られることを確認せよ.

    略

    ただし, 青で示したプロンプトに続いて数値 (太字) を入力している. これらのプロンプトに関しては, 書式は自由に定めてよいが, 必ず stderr に出力すること.

        xyz01234@DGLP00 ~/B4
        $ ./a
        n = 3
        [0][0] 1
        [0][1] 2
        [0][2] 3
        [1][0] 4
        [1][1] 5
        [1][2] 6
        [2][0] 7
        [2][1] 8
        [2][2] 9
        A
           1.00000   2.00000   3.00000
           4.00000   5.00000   6.00000
           7.00000   8.00000   9.00000
    
        xyz01234@DGLP00 ~/B4
        $

    [実行結果]
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % gcc matrix2test.c matrix.c
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % ./a.out                   
    n = 3
    [0][0] 1
    [0][1] 2
    [0][2] 3
    [1][0] 4
    [1][1] 5
    [1][2] 6
    [2][0] 7
    [2][1] 8
    [2][2] 9
    A
     1.00000 2.00000 3.00000
     4.00000 5.00000 6.00000
     7.00000 8.00000 9.00000

(3) matrix_sum
    配列 A と B に格納された n×n 行列の和を求め, 結果を配列 Y に格納する関数 void matrix_sum(int n, double A[N][N], double B[N][N], double Y[N][N]) を作成し, matrix.c に追加せよ.
    matrix.c を下記のテストプログラム(matrix3test)とリンクして実行して動作確認せよ.

    略

    適当に n=2 程度のデータを手入力して動作確認した後, 下記入出力が得られることを (diff で) 確認せよ.

    [in.txt]
    5

    3.25 9.42 7.34 0.12 5.98
    5.73 7.11 8.93 6.32 7.12
    8.23 5.44 3.12 0.29 4.23
    5.42 6.22 2.93 4.32 9.22
    7.13 1.36 9.34 4.21 4.31
    
    1.23 0.34 9.24 6.24 8.88
    2.59 0.13 3.19 7.36 6.35
    7.12 9.44 3.19 0.25 8.41
    3.42 9.43 4.23 7.99 8.43
    5.24 0.23 2.44 9.34 6.87

    [exp.txt]
    A
       3.25000   9.42000   7.34000   0.12000   5.98000
       5.73000   7.11000   8.93000   6.32000   7.12000
       8.23000   5.44000   3.12000   0.29000   4.23000
       5.42000   6.22000   2.93000   4.32000   9.22000
       7.13000   1.36000   9.34000   4.21000   4.31000
    B
       1.23000   0.34000   9.24000   6.24000   8.88000
       2.59000   0.13000   3.19000   7.36000   6.35000
       7.12000   9.44000   3.19000   0.25000   8.41000
       3.42000   9.43000   4.23000   7.99000   8.43000
       5.24000   0.23000   2.44000   9.34000   6.87000
    Y
       4.48000   9.76000  16.58000   6.36000  14.86000
       8.32000   7.24000  12.12000  13.68000  13.47000
      15.35000  14.88000   6.31000   0.54000  12.64000
       8.84000  15.65000   7.16000  12.31000  17.65000
      12.37000   1.59000  11.78000  13.55000  11.18000

    [実行結果]
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % gcc matrix3test.c matrix.c
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % ./a.out <in.txt> out.txt  
    n = A
    [0][0] [0][1] [0][2] [0][3] [0][4] [1][0] [1][1] [1][2] [1][3] [1][4] [2][0] [2][1] [2][2] [2][3] [2][4] [3][0] [3][1] [3][2] [3][3] [3][4] [4][0] [4][1] [4][2] [4][3] [4][4] B
    [0][0] [0][1] [0][2] [0][3] [0][4] [1][0] [1][1] [1][2] [1][3] [1][4] [2][0] [2][1] [2][2] [2][3] [2][4] [3][0] [3][1] [3][2] [3][3] [3][4] [4][0] [4][1] [4][2] [4][3] [4][4] %                                                                                                                                                      
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % diff -w out.txt exp.txt

    [out.txt]
    A
     3.25000 9.42000 7.34000 0.12000 5.98000
     5.73000 7.11000 8.93000 6.32000 7.12000
     8.23000 5.44000 3.12000 0.29000 4.23000
     5.42000 6.22000 2.93000 4.32000 9.22000
     7.13000 1.36000 9.34000 4.21000 4.31000
    B
     1.23000 0.34000 9.24000 6.24000 8.88000
     2.59000 0.13000 3.19000 7.36000 6.35000
     7.12000 9.44000 3.19000 0.25000 8.41000
     3.42000 9.43000 4.23000 7.99000 8.43000
     5.24000 0.23000 2.44000 9.34000 6.87000
    Y
     4.48000 9.76000 16.58000 6.36000 14.86000
     8.32000 7.24000 12.12000 13.68000 13.47000
     15.35000 14.88000 6.31000 0.54000 12.64000
     8.84000 15.65000 7.16000 12.31000 17.65000
     12.37000 1.59000 11.78000 13.55000 11.18000

(4) matrix_trans2
    配列 A に格納された n×n 行列の転置行列を求め, 結果を配列 Y に格納する関数 void matrix_trans2(int n, double A[N][N], double Y[N][N]) を作成し, matrix.c に追加せよ.
    matrix.c を下記のテストプログラム(matrix4test)とリンクして実行して動作確認せよ.

    略

    適当に n=2 程度のデータを手入力して動作確認した後, 下記入出力が得られることを (diff で) 確認せよ.

    [in.txt]	
    5

    3.25 9.42 7.34 0.12 5.98
    5.73 7.11 8.93 6.32 7.12
    8.23 5.44 3.12 0.29 4.23
    5.42 6.22 2.93 4.32 9.22
    7.13 1.36 9.34 4.21 4.31

    [exp.txt]
    A
       3.25000   9.42000   7.34000   0.12000   5.98000
       5.73000   7.11000   8.93000   6.32000   7.12000
       8.23000   5.44000   3.12000   0.29000   4.23000
       5.42000   6.22000   2.93000   4.32000   9.22000
       7.13000   1.36000   9.34000   4.21000   4.31000
    Y
       3.25000   5.73000   8.23000   5.42000   7.13000
       9.42000   7.11000   5.44000   6.22000   1.36000
       7.34000   8.93000   3.12000   2.93000   9.34000
       0.12000   6.32000   0.29000   4.32000   4.21000
       5.98000   7.12000   4.23000   9.22000   4.31000

    [実行結果]

    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % gcc matrix4test.c matrix.c
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % ./a.out <in.txt> out.txt  
    n = A
    [0][0] [0][1] [0][2] [0][3] [0][4] [1][0] [1][1] [1][2] [1][3] [1][4] [2][0] [2][1] [2][2] [2][3] [2][4] [3][0] [3][1] [3][2] [3][3] [3][4] [4][0] [4][1] [4][2] [4][3] [4][4] %                                                                                                                                                      
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % diff -w out.txt exp.txt   

    [out.txt]
    A
     3.25000 9.42000 7.34000 0.12000 5.98000
     5.73000 7.11000 8.93000 6.32000 7.12000
     8.23000 5.44000 3.12000 0.29000 4.23000
     5.42000 6.22000 2.93000 4.32000 9.22000
     7.13000 1.36000 9.34000 4.21000 4.31000
    Y
     3.25000 5.73000 8.23000 5.42000 7.13000
     9.42000 7.11000 5.44000 6.22000 1.36000
     7.34000 8.93000 3.12000 2.93000 9.34000
     0.12000 6.32000 0.29000 4.32000 4.21000
     5.98000 7.12000 4.23000 9.22000 4.31000

(5) matrix_trans1
    配列 A に格納された n×n 行列を転置する (転置の結果を A に格納する) 関数 void matrix_trans1(int n, double A[N][N]) を作成し, matrix.c に追加せよ.
    ただし, matrix_trans1 の中で A 以外の配列を宣言して用いてはならない.

    matrix.c を下記のテストプログラム(matrix5test)とリンクして実行し, (4) の matrix_trans2 と同様の動作確認を行え.

    略

    [in.txt]	
    5

    3.25 9.42 7.34 0.12 5.98
    5.73 7.11 8.93 6.32 7.12
    8.23 5.44 3.12 0.29 4.23
    5.42 6.22 2.93 4.32 9.22
    7.13 1.36 9.34 4.21 4.31

    [exp.txt]
    A
       3.25000   9.42000   7.34000   0.12000   5.98000
       5.73000   7.11000   8.93000   6.32000   7.12000
       8.23000   5.44000   3.12000   0.29000   4.23000
       5.42000   6.22000   2.93000   4.32000   9.22000
       7.13000   1.36000   9.34000   4.21000   4.31000
    A
       3.25000   5.73000   8.23000   5.42000   7.13000
       9.42000   7.11000   5.44000   6.22000   1.36000
       7.34000   8.93000   3.12000   2.93000   9.34000
       0.12000   6.32000   0.29000   4.32000   4.21000
       5.98000   7.12000   4.23000   9.22000   4.31000

    [実行結果]
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % gcc matrix5test.c matrix.c -Wall
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % ./a.out <in.txt> out.txt        
    n = A
    [0][0] [0][1] [0][2] [0][3] [0][4] [1][0] [1][1] [1][2] [1][3] [1][4] [2][0] [2][1] [2][2] [2][3] [2][4] [3][0] [3][1] [3][2] [3][3] [3][4] [4][0] [4][1] [4][2] [4][3] [4][4] %                                                                                                                                                      
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % diff -w out.txt exp.txt  

    [out.txt]
    A
     3.25000 9.42000 7.34000 0.12000 5.98000
     5.73000 7.11000 8.93000 6.32000 7.12000
     8.23000 5.44000 3.12000 0.29000 4.23000
     5.42000 6.22000 2.93000 4.32000 9.22000
     7.13000 1.36000 9.34000 4.21000 4.31000
    A
     3.25000 5.73000 8.23000 5.42000 7.13000
     9.42000 7.11000 5.44000 6.22000 1.36000
     7.34000 8.93000 3.12000 2.93000 9.34000
     0.12000 6.32000 0.29000 4.32000 4.21000
     5.98000 7.12000 4.23000 9.22000 4.31000

(6) vector_scan, vector_print
    標準入力から n 次元ベクトルのデータを配列 x[N] に読み込む関数 void vector_scan(int n, double x[N]) を matrix.c に追加せよ. 
    また, 配列 x[N] に格納された n 次元ベクトルのデータを標準出力に出力する関数 void vector_print(int n, double x[N]) を作成せよ. 数値の出力フォーマットは matrix_print と同様にせよ.
    matrix.c を下記のテストプログラム(matrix6test)とリンクして実行して (適当な手入力で) 動作確認せよ.

    略

    [実行結果]
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % gcc matrix6test.c matrix.c -Wall
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % ./a.out                         
    n = 3
    x
    1 2 3
    x
    2.00000
    4.00000
    6.00000

(7) matrix_vector_prod
    A[N][N] に格納された n×n 行列 と, x[N] に格納された n 次元ベクトルとの積を計算し, 結果を y[N] に格納する関数 void matrix_vector_prod(int n, double A[N][N], double x[N], double y[N]) を matrix.c の中に作成せよ.

    標準入力より A と x を入力して y = A x を計算し, y を標準出力に出力するテストプログラム matrix7test.c を, (3) の matrix3test.c に倣って作成せよ.

    matrix7test.c と matrix.c をリンクして実行し, (手入力で) 上記の【参考】の結果が得られることを確認せよ.

    次に, 下記入出力が得られることを (diff で) 確認せよ.
    in.txt	
    5

    3.25 9.42 7.34 0.12 5.98
    5.73 7.11 8.93 6.32 7.12
    8.23 5.44 3.12 0.29 4.23
    5.42 6.22 2.93 4.32 9.22
    7.13 1.36 9.34 4.21 4.31

    1.23
    0.34
    9.24
    6.24
    8.88

    exp.txt
    A
       3.25000   9.42000   7.34000   0.12000   5.98000
       5.73000   7.11000   8.93000   6.32000   7.12000
       8.23000   5.44000   3.12000   0.29000   4.23000
       5.42000   6.22000   2.93000   4.32000   9.22000
       7.13000   1.36000   9.34000   4.21000   4.31000
    x
       1.23000
       0.34000
       9.24000
       6.24000
       8.88000
    y
     128.87310
     194.64090
      80.17330
     144.68500
     160.07710

    [実行結果]
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % gcc matrix7test.c matrix.c -Wall
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % ./a.out <in.txt> out.txt        
    n = A
    [0][0] [0][1] [0][2] [0][3] [0][4] [1][0] [1][1] [1][2] [1][3] [1][4] [2][0] [2][1] [2][2] [2][3] [2][4] [3][0] [3][1] [3][2] [3][3] [3][4] [4][0] [4][1] [4][2] [4][3] [4][4] x
    (base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % diff -w out.txt exp.txt  

[感想]
この課題では、標準入力で行列の要素を読み込んで和の計算、転置行列に変換、計算結果の表示などの操作を行う関数を作成した。
特に(5)の転置行列を表示する問題が少し厄介だった。二重ループのi,jの初期値をkとして、kを二重ループが終わる度に+1することで
このプログラムを実現できた。

----------------------------------------
[課題 4.2]
(1) 色調の変更 (image1cool.c)
    下記の指示に従い, 画像を全体に「涼しげ」にするプログラム image1cool.c を完成させよ.

    1.次の画像をこの演習用のフォルダに in.bmp として保存せよ.
    2.次の image1cool.c, image1.h, image1.c をファイルに保存し, コンパイル・リンクせよ.
        ・image1cool.c はこの課題のプログラムの雛形である.
        ・image1.h はビットマップデータ構造の定義と, 画像の入出力を行う関数のプロトタイプ宣言である.
        ・image1.c は画像の入出力を行う関数の本体である
    3.プログラムを実行せよ (コマンドライン引数はないので, ./a だけでよい).
        ・in.bmp を読み込んで処理を行った結果が out.bmp に書き出される.
        ・out.bmp を開いて結果を確認せよ.
        ・現状の image1cool.c には, 画像を全体に暗くする (R, G, B 全ての輝度を 0.5 倍にする) 処理が書かれている.
    4.image1cool.c の関数 bmp_cool の中を書き換え, 赤の輝度のみ 0.8 倍にし, 緑と青の輝度は変更しない (元の 1.0 倍とする) ようにせよ.
    
(2) モノクロ化 (image1mono.c)
ビットマップ画像 in.bmp を入力し, 画像をモノクロに変換して out.bmp に出力するプログラム image1mono.c を作成せよ. 全画素について R, G, B の値を等しくすればモノクロ画像になる. 値は R, G, B の平均値にすればよい.

(3) フレームの描画 (image1frame.c)
ビットマップ画像 in.bmp を入力し, 幅8画素でピンク色のフレーム (外枠) を付加して out.bmp に出力するプログラム image1frame.c を作成せよ. 細長い長方形を 4 つ描画すればよい. 色を適切に調整せよせよ.

(4) 鏡像 (image1mirror.c)
ビットマップ画像 in.bmp を入力し, 上下を反転させた画像 (下図参照) を out.bmp に出力するプログラム image1mirror.c を作成せよ.

(5) モザイク (image1mosaic.c)
in.bmp の画像の左半分に 16×16 画素のモザイクをかけて out.bmp に出力するプログラム image1mosaic.c を作成せよ. 16×16 画素毎に (その 256 画素の) 平均値を計算し, その値をその 16×16 画素すべてに代入すればよい.

(6) 縮小 (image1collapse.c)
in.bmp の縦方向のサイズを半分に縮小して out.bmp に出力するプログラム image1collapse.c を作成せよ.
新画像の (x,y) の画素の値を, 元画像の (x,2y) と (x,2y+1) の平均値とすればよい.
ヘッダの biHeight の値を半分にせよ.

[実行結果]
(1)〜(6)それぞれの条件に合ったout.bmpを出力することができた。

[感想]
それぞれの処理において、元の画素値と処理後の画素値の関係を考えることで実装がうまくいけた気がする。
自分が一番躓いたのは(5)のモザイク処理であったが、二重ループのカウンタ変数x,yの周回条件を考えることで実装することができた。
メディア工学基礎の授業で取り組んだマトリックスも自分で実装してみたい。

----------------------------------------
[課題 4.3]
課題 (4-2) において, ビットマップのヘッダ (bmp_header_t 型) と画素配列 (pixel_t の2次元配列) をまとめ, 次のような一つの構造体型 bmp_data_t で表現するように変更したい.

    typedef struct {
      bmp_header_t header;
      pixel_t img[MAX_Y][MAX_X];
    } bmp_data_t;

即ち, image1.h を次の image2.h に変更する. image1.c と image1collapse.c をそれぞれこのデータ構造に適合する image2.c, image2collapse.c に書き換えよ. (作業自体は単純だが, image1.c の修正量が多く, 構造体型の書き換えでミスが出やすいので, 心して取り組むこと.)

[実行結果]
(base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % gcc image2collapse.c image2.c -Wall
(base) nishiokayuuta@nishiokayuutanoMacBook-Air 4回目 % ./a.out
input file = "in.bmp"
output file = out.bmp

[感想]
image2.cでは、関数bmp_readとbmp_writeの引数の型をbmp_data_tとすることで、image1.cでの引数pixel_t img[MAX_Y][MAX_X]を書く必要がなくなり、
可読性が上がった。また、ヘッダ情報の読み込みの記述でbmp_header_tのメンバ変数を示す場合は、*hdというbmp_data_t型のポインタ変数を指定した場合、&hd->header.[メンバ変数]と記述すれば良いと分かった。
一方、image2collapse.cにおいても関数の引数がbmp_data_tとなっていて、画素値img[i][j]はメンバ変数なので、hd->img[i][j]というように使えば良い。
型定義に関して、理解が深まる課題であったと感じた。


----------------------------------------

[課題 B4 の感想]
今回の課題は、主に二次元配列の操作でモザイク処理やサイズの圧縮を行うといったものであったが、前回のポインタも活かすことができた。
ポインタの理解を深めて、データ構造とアルゴリズムの授業で習ったリスト処理も実装できるようにしたい。
